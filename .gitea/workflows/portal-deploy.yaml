name: Portal Build & Deploy (k3s)

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'deploy/**'
      - '.gitea/workflows/portal-deploy.yaml'
  workflow_dispatch:

concurrency:
  group: portal-deploy
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: linux
    defaults:
      run:
        shell: sh
    env:
      REGISTRY: ${{ secrets.REGISTRY }}
      BACKEND_IMAGE: ${{ secrets.REGISTRY }}/hydrosim-portal-backend
      FRONTEND_IMAGE: ${{ secrets.REGISTRY }}/hydrosim-portal-frontend
      IMAGE_TAG: ${{ github.sha }}
    steps:
      - name: Trust Gitea CA (optional)
        if: ${{ secrets.GITEA_CA_CERT != '' }}
        run: |
          set +e
          echo "${{ secrets.GITEA_CA_CERT }}" > "$RUNNER_TEMP/gitea.crt"
          if command -v update-ca-certificates >/dev/null 2>&1; then
            cp "$RUNNER_TEMP/gitea.crt" /usr/local/share/ca-certificates/gitea.crt || true
            update-ca-certificates || true
          elif command -v update-ca-trust >/dev/null 2>&1; then
            cp "$RUNNER_TEMP/gitea.crt" /etc/pki/ca-trust/source/anchors/gitea.crt || true
            update-ca-trust || true
          else
            echo "No system CA update tool found. Consider setting GIT_SSL_NO_VERIFY=true."
          fi

      - name: Debug runner context
        shell: sh
        run: |
          set -e
          echo "GITHUB_SERVER_URL=${GITHUB_SERVER_URL:-}"
          echo "GITHUB_REPOSITORY=${GITHUB_REPOSITORY:-}"
          echo "GITHUB_REF=${GITHUB_REF:-}"
          echo "GITEA_SERVER_URL=${GITEA_SERVER_URL:-}"
          echo "KUBERNETES_SERVICE_HOST=${KUBERNETES_SERVICE_HOST:-}"
          if [ -f /var/run/secrets/kubernetes.io/serviceaccount/token ]; then
            echo "SA_TOKEN_PRESENT=yes"
          else
            echo "SA_TOKEN_PRESENT=no"
          fi
          uname -a || true
          id || true
          pwd
          ls -la
          if command -v git >/dev/null 2>&1; then
            git --version
          else
            echo "git not found"
          fi
          if command -v docker >/dev/null 2>&1; then
            docker --version
          else
            echo "docker not found"
          fi

      - name: Normalize registry config
        shell: sh
        env:
          REGISTRY: ${{ secrets.REGISTRY }}
        run: |
          set -e
          if [ -z "${REGISTRY:-}" ]; then
            echo "Missing REGISTRY secret."
            exit 1
          fi
          REGISTRY_INSECURE_EFFECTIVE="false"
          if echo "$REGISTRY" | grep -q '^http://'; then
            REGISTRY_INSECURE_EFFECTIVE="true"
          fi
          REGISTRY_HOST="${REGISTRY#https://}"
          REGISTRY_HOST="${REGISTRY_HOST#http://}"
          if [ "${{ secrets.REGISTRY_INSECURE }}" = "true" ]; then
            REGISTRY_INSECURE_EFFECTIVE="true"
          fi
          echo "REGISTRY_HOST=$REGISTRY_HOST" >> "$GITHUB_ENV"
          echo "BACKEND_IMAGE=$REGISTRY_HOST/hydrosim-portal-backend" >> "$GITHUB_ENV"
          echo "FRONTEND_IMAGE=$REGISTRY_HOST/hydrosim-portal-frontend" >> "$GITHUB_ENV"
          echo "REGISTRY_INSECURE_EFFECTIVE=$REGISTRY_INSECURE_EFFECTIVE" >> "$GITHUB_ENV"

      - name: Checkout (manual)
        shell: sh
        env:
          GIT_SSL_NO_VERIFY: ${{ secrets.GIT_SSL_NO_VERIFY }}
          GITEA_URL: ${{ secrets.GITEA_URL }}
          GITEA_TOKEN: ${{ secrets.GITEA_TOKEN }}
          GITEA_USERNAME: ${{ secrets.GITEA_USERNAME }}
          GITEA_REPOSITORY: ${{ secrets.GITEA_REPOSITORY }}
        run: |
          set -e
          WORKDIR="${GITHUB_WORKSPACE:-$PWD}"
          mkdir -p "$WORKDIR"
          cd "$WORKDIR"
          REPO_URL=""
          if [ -n "${GITHUB_SERVER_URL:-}" ] && [ -n "${GITHUB_REPOSITORY:-}" ]; then
            REPO_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git"
          elif [ -n "${GITEA_URL:-}" ] && [ -n "${GITEA_REPOSITORY:-}" ]; then
            REPO_URL="${GITEA_URL}/${GITEA_REPOSITORY}.git"
          fi
          if [ -z "$REPO_URL" ]; then
            echo "Missing repository info. Provide GITHUB_SERVER_URL/GITHUB_REPOSITORY or GITEA_URL/GITEA_REPOSITORY."
            exit 1
          fi
          git init
          git remote add origin "$REPO_URL"
          FETCH_REF="${GITHUB_SHA:-${GITHUB_REF:-refs/heads/main}}"
          if [ -n "${GITEA_TOKEN:-}" ]; then
            USERNAME="${GITEA_USERNAME:-oauth2}"
            AUTH="$(printf "%s:%s" "$USERNAME" "$GITEA_TOKEN" | base64 | tr -d '\n')"
            git -c http.extraHeader="Authorization: Basic $AUTH" fetch --depth 1 origin "$FETCH_REF"
            git -c http.extraHeader="Authorization: Basic $AUTH" checkout -q FETCH_HEAD
          else
            git fetch --depth 1 origin "$FETCH_REF"
            git checkout -q FETCH_HEAD
          fi

      - name: Ensure kubectl
        shell: sh
        run: |
          set -e
          if command -v kubectl >/dev/null 2>&1; then
            kubectl version --client
            exit 0
          fi
          ARCH="$(uname -m)"
          case "$ARCH" in
            x86_64|amd64) ARCH=amd64 ;;
            aarch64|arm64) ARCH=arm64 ;;
          esac
          KUBECTL_BIN="$RUNNER_TEMP/kubectl"
          if command -v curl >/dev/null 2>&1; then
            curl -fsSL "https://dl.k8s.io/release/v1.27.0/bin/linux/$ARCH/kubectl" -o "$KUBECTL_BIN"
          elif command -v wget >/dev/null 2>&1; then
            wget -qO "$KUBECTL_BIN" "https://dl.k8s.io/release/v1.27.0/bin/linux/$ARCH/kubectl"
          else
            echo "curl or wget is required to download kubectl."
            exit 1
          fi
          chmod +x "$KUBECTL_BIN"
          echo "$RUNNER_TEMP" >> "$GITHUB_PATH"

      - name: Configure kubeconfig
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG_DATA }}
        run: |
          set -e
          if [ -n "${KUBECONFIG_DATA:-}" ]; then
            echo "kubeconfig source: KUBECONFIG_DATA"
            echo "$KUBECONFIG_DATA" | base64 -d > "$RUNNER_TEMP/kubeconfig"
          elif [ -f /var/run/secrets/kubernetes.io/serviceaccount/token ]; then
            echo "kubeconfig source: in-cluster serviceaccount"
            SERVER="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"
            TOKEN="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)"
            CA="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
            NS="$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)"
            cat > "$RUNNER_TEMP/kubeconfig" <<EOF
apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority: ${CA}
    server: ${SERVER}
  name: in-cluster
users:
- name: sa
  user:
    token: ${TOKEN}
contexts:
- context:
    cluster: in-cluster
    user: sa
    namespace: ${NS}
  name: in-cluster
current-context: in-cluster
EOF
          else
            echo "Missing KUBECONFIG_DATA and no in-cluster serviceaccount token found."
            exit 1
          fi
          if [ -n "${{ secrets.KUBE_SERVER }}" ]; then
            CLUSTER="$(KUBECONFIG=$RUNNER_TEMP/kubeconfig kubectl config get-clusters | tail -n +2 | head -n 1)"
            KUBECONFIG=$RUNNER_TEMP/kubeconfig kubectl config set-cluster "$CLUSTER" --server="${{ secrets.KUBE_SERVER }}"
          fi
          if [ "${{ secrets.KUBE_INSECURE }}" = "true" ]; then
            CLUSTER="$(KUBECONFIG=$RUNNER_TEMP/kubeconfig kubectl config get-clusters | tail -n +2 | head -n 1)"
            KUBECONFIG=$RUNNER_TEMP/kubeconfig kubectl config set-cluster "$CLUSTER" --insecure-skip-tls-verify=true
          fi
          echo "KUBECONFIG=$RUNNER_TEMP/kubeconfig" >> $GITHUB_ENV

      - name: Debug kubeconfig
        run: |
          set +e
          exec 2>&1
          echo "RUNNER_TEMP=${RUNNER_TEMP:-}"
          export KUBECONFIG="${KUBECONFIG:-$RUNNER_TEMP/kubeconfig}"
          echo "KUBECONFIG=$KUBECONFIG"
          ls -la "$RUNNER_TEMP" || true
          ls -la "$KUBECONFIG" || true
          if [ -f "$KUBECONFIG" ]; then
            echo "kubeconfig_bytes=$(wc -c < "$KUBECONFIG")"
          else
            echo "kubeconfig missing"
          fi
          kubectl config get-contexts 2>&1 || true
          kubectl config current-context 2>&1 || true
          kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}{"\n"}' 2>&1 || true
          kubectl config view --minify -o jsonpath='{.users[0].name}{"\n"}' 2>&1 || true

      - name: Verify cluster access
        run: |
          set -e
          exec 2>&1
          set -x
          if ! command -v kubectl >/dev/null 2>&1; then
            echo "kubectl not found in PATH."
            exit 1
          fi
          export KUBECONFIG="${KUBECONFIG:-$RUNNER_TEMP/kubeconfig}"
          kubectl version --client --output=yaml
          kubectl cluster-info --request-timeout=5s
          kubectl -n hydrosim get pods --request-timeout=5s

      - name: Prepare in-cluster build secrets
        shell: sh
        env:
          REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
          REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
          GITEA_URL: ${{ secrets.GITEA_URL }}
          GITEA_REPOSITORY: ${{ secrets.GITEA_REPOSITORY }}
          GITEA_TOKEN: ${{ secrets.GITEA_TOKEN }}
          GITEA_USERNAME: ${{ secrets.GITEA_USERNAME }}
          GIT_SSL_NO_VERIFY: ${{ secrets.GIT_SSL_NO_VERIFY }}
        run: |
          set -e
          if [ -z "${REGISTRY_USERNAME:-}" ] || [ -z "${REGISTRY_PASSWORD:-}" ]; then
            echo "Missing REGISTRY_USERNAME or REGISTRY_PASSWORD."
            exit 1
          fi
          if [ -z "${GITEA_URL:-}" ] || [ -z "${GITEA_REPOSITORY:-}" ]; then
            echo "Missing GITEA_URL or GITEA_REPOSITORY."
            exit 1
          fi
          GIT_CLONE_URL="${GITEA_URL%/}/${GITEA_REPOSITORY}.git"
          kubectl -n hydrosim create secret docker-registry kaniko-registry-auth \
            --docker-server="$REGISTRY_HOST" \
            --docker-username="$REGISTRY_USERNAME" \
            --docker-password="$REGISTRY_PASSWORD" \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n hydrosim create secret generic portal-git-credentials \
            --from-literal=GIT_CLONE_URL="$GIT_CLONE_URL" \
            --from-literal=GIT_USERNAME="${GITEA_USERNAME:-oauth2}" \
            --from-literal=GIT_TOKEN="${GITEA_TOKEN:-}" \
            --from-literal=GIT_REF="${GITHUB_SHA}" \
            --from-literal=GIT_SSL_NO_VERIFY="${GIT_SSL_NO_VERIFY:-}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Build backend image in k3s (kaniko)
        shell: sh
        run: |
          set -e
          kubectl -n hydrosim delete job portal-build-backend --ignore-not-found
          cat <<EOF | kubectl apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: portal-build-backend
            namespace: hydrosim
          spec:
            backoffLimit: 0
            ttlSecondsAfterFinished: 300
            template:
              spec:
                restartPolicy: Never
                volumes:
                  - name: workspace
                    emptyDir: {}
                  - name: docker-config
                    secret:
                      secretName: kaniko-registry-auth
                      items:
                        - key: .dockerconfigjson
                          path: config.json
                initContainers:
                  - name: git-clone
                    image: alpine/git:2.45.2
                    env:
                      - name: GIT_CLONE_URL
                        valueFrom:
                          secretKeyRef:
                            name: portal-git-credentials
                            key: GIT_CLONE_URL
                      - name: GIT_USERNAME
                        valueFrom:
                          secretKeyRef:
                            name: portal-git-credentials
                            key: GIT_USERNAME
                      - name: GIT_TOKEN
                        valueFrom:
                          secretKeyRef:
                            name: portal-git-credentials
                            key: GIT_TOKEN
                      - name: GIT_REF
                        valueFrom:
                          secretKeyRef:
                            name: portal-git-credentials
                            key: GIT_REF
                      - name: GIT_SSL_NO_VERIFY
                        valueFrom:
                          secretKeyRef:
                            name: portal-git-credentials
                            key: GIT_SSL_NO_VERIFY
                    command: ["sh", "-c"]
                    args:
                      - |
                        set -e
                        export GIT_SSL_NO_VERIFY="${GIT_SSL_NO_VERIFY:-}"
                        cd /workspace
                        git init
                        git remote add origin "$GIT_CLONE_URL"
                        if [ -n "$GIT_TOKEN" ]; then
                          AUTH="$(printf "%s:%s" "$GIT_USERNAME" "$GIT_TOKEN" | base64 | tr -d '\n')"
                          git -c http.extraHeader="Authorization: Basic $AUTH" fetch --depth 1 origin "$GIT_REF"
                          git -c http.extraHeader="Authorization: Basic $AUTH" checkout -q FETCH_HEAD
                        else
                          git fetch --depth 1 origin "$GIT_REF"
                          git checkout -q FETCH_HEAD
                        fi
                    volumeMounts:
                      - name: workspace
                        mountPath: /workspace
                containers:
                  - name: kaniko
                    image: gcr.io/kaniko-project/executor:v1.23.2
                    env:
                      - name: BACKEND_IMAGE
                        value: "$BACKEND_IMAGE"
                      - name: IMAGE_TAG
                        value: "$IMAGE_TAG"
                      - name: REGISTRY_INSECURE
                        value: "$REGISTRY_INSECURE_EFFECTIVE"
                    args:
                      - --context=dir:///workspace
                      - --dockerfile=backend/Dockerfile
                      - --destination=$(BACKEND_IMAGE):$(IMAGE_TAG)
                      - --snapshotMode=redo
                      - --verbosity=info
                      - --insecure=$(REGISTRY_INSECURE)
                      - --skip-tls-verify=$(REGISTRY_INSECURE)
                    volumeMounts:
                      - name: workspace
                        mountPath: /workspace
                      - name: docker-config
                        mountPath: /kaniko/.docker
          EOF
          if ! kubectl -n hydrosim wait --for=condition=complete job/portal-build-backend --timeout=1200s; then
            kubectl -n hydrosim logs job/portal-build-backend --all-containers || true
            exit 1
          fi

      - name: Build frontend image in k3s (kaniko)
        shell: sh
        run: |
          set -e
          kubectl -n hydrosim delete job portal-build-frontend --ignore-not-found
          cat <<EOF | kubectl apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: portal-build-frontend
            namespace: hydrosim
          spec:
            backoffLimit: 0
            ttlSecondsAfterFinished: 300
            template:
              spec:
                restartPolicy: Never
                volumes:
                  - name: workspace
                    emptyDir: {}
                  - name: docker-config
                    secret:
                      secretName: kaniko-registry-auth
                      items:
                        - key: .dockerconfigjson
                          path: config.json
                initContainers:
                  - name: git-clone
                    image: alpine/git:2.45.2
                    env:
                      - name: GIT_CLONE_URL
                        valueFrom:
                          secretKeyRef:
                            name: portal-git-credentials
                            key: GIT_CLONE_URL
                      - name: GIT_USERNAME
                        valueFrom:
                          secretKeyRef:
                            name: portal-git-credentials
                            key: GIT_USERNAME
                      - name: GIT_TOKEN
                        valueFrom:
                          secretKeyRef:
                            name: portal-git-credentials
                            key: GIT_TOKEN
                      - name: GIT_REF
                        valueFrom:
                          secretKeyRef:
                            name: portal-git-credentials
                            key: GIT_REF
                      - name: GIT_SSL_NO_VERIFY
                        valueFrom:
                          secretKeyRef:
                            name: portal-git-credentials
                            key: GIT_SSL_NO_VERIFY
                    command: ["sh", "-c"]
                    args:
                      - |
                        set -e
                        export GIT_SSL_NO_VERIFY="${GIT_SSL_NO_VERIFY:-}"
                        cd /workspace
                        git init
                        git remote add origin "$GIT_CLONE_URL"
                        if [ -n "$GIT_TOKEN" ]; then
                          AUTH="$(printf "%s:%s" "$GIT_USERNAME" "$GIT_TOKEN" | base64 | tr -d '\n')"
                          git -c http.extraHeader="Authorization: Basic $AUTH" fetch --depth 1 origin "$GIT_REF"
                          git -c http.extraHeader="Authorization: Basic $AUTH" checkout -q FETCH_HEAD
                        else
                          git fetch --depth 1 origin "$GIT_REF"
                          git checkout -q FETCH_HEAD
                        fi
                    volumeMounts:
                      - name: workspace
                        mountPath: /workspace
                containers:
                  - name: kaniko
                    image: gcr.io/kaniko-project/executor:v1.23.2
                    env:
                      - name: FRONTEND_IMAGE
                        value: "$FRONTEND_IMAGE"
                      - name: IMAGE_TAG
                        value: "$IMAGE_TAG"
                      - name: REGISTRY_INSECURE
                        value: "$REGISTRY_INSECURE_EFFECTIVE"
                    args:
                      - --context=dir:///workspace
                      - --dockerfile=frontend/Dockerfile
                      - --destination=$(FRONTEND_IMAGE):$(IMAGE_TAG)
                      - --snapshotMode=redo
                      - --verbosity=info
                      - --insecure=$(REGISTRY_INSECURE)
                      - --skip-tls-verify=$(REGISTRY_INSECURE)
                    volumeMounts:
                      - name: workspace
                        mountPath: /workspace
                      - name: docker-config
                        mountPath: /kaniko/.docker
          EOF
          if ! kubectl -n hydrosim wait --for=condition=complete job/portal-build-frontend --timeout=1200s; then
            kubectl -n hydrosim logs job/portal-build-frontend --all-containers || true
            exit 1
          fi

      - name: Apply base and postgres manifests
        run: |
          if [ "${{ secrets.APPLY_BASE }}" != "false" ]; then
            kubectl apply -f deploy/base/
          fi
          if [ "${{ secrets.APPLY_POSTGRES }}" != "false" ]; then
            kubectl apply -f deploy/infra/postgres.yaml
          fi

      - name: Apply backend config and secrets
        run: |
          kubectl -n hydrosim create secret generic portal-backend-secret \
            --from-literal=DATABASE_URL="${{ secrets.DATABASE_URL }}" \
            --from-literal=JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}" \
            --from-literal=MINIO_ACCESS_KEY="${{ secrets.MINIO_ACCESS_KEY }}" \
            --from-literal=MINIO_SECRET_KEY="${{ secrets.MINIO_SECRET_KEY }}" \
            --from-literal=GITEA_TOKEN="${{ secrets.GITEA_TOKEN }}" \
            --from-literal=DEPLOY_TRIGGER_TOKEN="${{ secrets.DEPLOY_TRIGGER_TOKEN }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n hydrosim create configmap portal-backend-config \
            --from-literal=PORTAL_ENV=production \
            --from-literal=K8S_IN_CLUSTER=true \
            --from-literal=K8S_NAMESPACE=hydrosim \
            --from-literal=GITEA_URL="${{ secrets.GITEA_URL }}" \
            --from-literal=MINIO_ENDPOINT="${{ secrets.MINIO_ENDPOINT }}" \
            --from-literal=MINIO_BUCKET="${{ secrets.MINIO_BUCKET }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy backend
        run: |
          kubectl apply -f deploy/backend/deployment.yaml -f deploy/backend/service.yaml
          kubectl -n hydrosim set image deploy/portal-backend portal-backend="$BACKEND_IMAGE:${IMAGE_TAG}"
          kubectl -n hydrosim rollout status deploy/portal-backend --timeout=180s

      - name: Deploy frontend
        run: |
          kubectl apply -f deploy/frontend/deployment.yaml -f deploy/frontend/service.yaml
          kubectl -n hydrosim set image deploy/portal-frontend portal-frontend="$FRONTEND_IMAGE:${IMAGE_TAG}"
          kubectl -n hydrosim rollout status deploy/portal-frontend --timeout=180s

      - name: Apply ingress
        run: kubectl apply -f deploy/ingress/

      - name: Migrate DB (optional)
        if: ${{ secrets.RUN_DB_MIGRATION == 'true' }}
        run: |
          kubectl -n hydrosim exec deploy/portal-backend -- alembic upgrade head
